- 👋 Hi, I’m @seiyes
- 👀 I’m interested in msa, ddd, SaaS, mdd etc
- 🌱 I’m currently learning integrated architecture
- 💞️ I’m looking to collaborate on test
- 📫 How to reach me test

<!---
seiyes/seiyes is a ✨ special ✨ repository because its `README.md` (this file) appears on your GitHub profile.
You can click the Preview link to take a look at your changes.
--->
<구독형 
1.	유연한 데이터 
2.	소스 변경 없는 특화 로직 반영
3.	서로 다른 화면 항목 설계
4.	회사마다 다른 비즈니스 룰 처리

물론 이러한 설계보다 가장 먼저 알아야 하는 것은 SaaS형 어플리케이션은 하나의 사이트에 배포가 되는 것이 아닌 서비스를 구독하고, 서비스 구독량에 따라 사용료를 지불하는 방식이라는 것을 확실히 알아야 한다. 따라서 가장 기본적인 사항은 싱글 인스턴스로 여러 회사 혹은 여러 사용자에게 서비스를 해야 하는 것으로 각각의 회사나 사용자 그룹을 구분할 수 있는 구분자가 DB에 존재해야 한다. 이 구분자를 일반적으로 테넌트라 명명하며, 테넌트 별로 데이터 혹은 소스가 관리될 수 있도록 데이터 모델과 소스 정책이 수립되어야 하는 것이 기본이다.
자 그렇다면 위에서 언급된 예제를 기반으로 설계 패턴에 대하여 SaaS형 어플리케이션에 대한 특성을 알아보도록 하자.
2. 유연한 데이터 모델
________________________________________
데이터 모델에 대한 유연성의 수준은 일반화 수준이라고 생각할 수 있다. 분류에 의하여 동물은 일반화가 가장 높은 레벨이라고 하면 양서류, 파충류, 포유류는 동물의 구체화 된 형태라고 볼 수 있는 것이다. 구체적일수록 모습을 이해하기 쉽고, 일반화될수록 모습을 이해하기는 어려운 특징이 있다. 데이터 모델에서의 일반화의 가장 높은 레벨을 살펴보자
 
세상의 모든 데이터는 이 5개의 엔터티로 다 정의될 수 있다. 사람과 조직의 예를 들어보자
•	Party : 사람 혹은 조직의 정보를 정의
•	Party Role : 조직이나 사람의 역할을 정의
(ex) Customer, Supplier, employer etc.
•	Party Relationship : Party Role과의 관계를 정의
(예) 사람과 조직 관계 Employment, Customer Relationship등
•	Party Relationship type : Party Relationship의 정보를 관리
•	Role Type : Role 에 대한 정보를 관리하는 엔터티
Order, 구매 등도 주요 엔터티은 Party와 Party간의 관계를 통해서 데이터 모델을 추상화 하여 관리할 수 있다. 즉, 엔터티와 엔터티와의 관계 설정을 통하여 데이터 모델을 만드는 것이다. 이 모델의 장점은 유연하여 어떠한 업무도 이 모델에 다 반영할 수 있다는 것이고, 단점은 모델을 보고 어떠한 업무인지를 절대 알 수 없다는 것이다.
좀 더 구체적인 업무를 통하여 특성을 살펴보도록 하자. 다음은 보험의 청약과 청약 관계자 정보에 대한 모델 비교이다
 

Type B가 이해하기 쉽다고 하더라고, SaaS형 어플리케이션은 여러 회사의 관계자가 다 다를 수 있기 때문에 관계자구분코드를 설정을 통하여 정의 후 사용할 수 있는 Type A 형태로 구축되어야 한다.  
3. 소스 변경 없는 특화 로직 반영
________________________________________
일단 SaaS형 어플리케이션은 이미 다른 사이트나 사용자가 이미 사용하고 있는 어플리케이션이므로 이를 함부로 수정하여 배포하는 것이 가장 위험한 일이다. 따라서 가능하면 소스를 수정하지 않고 각 회사마다 다른 로직을 반영할 수 있는 구조로 어플리케이션을 설계해야 한다. 이 때 가장 많이 사용하는 디자인 패턴이 Factory Pattern이다. 주 로직에 If/Else 혹은 Case 문으로 구현되는 것을 지양하고, 그 회사에 맞는 로직을 다른 객체에 구현하여 회사별 구현 객체를 호출할 수 있는 구조로 만드는 것이다. 이를 보험 업무의 청약 시 인수 심사에 대한 룰을 회사마다 규칙이 다르더라도 소스 변경 없이 변경할 수 있는 구조를 모델링한 방식이다.
인수 심사는 각 회사마다 규칙이 다르고, 이 규칙을 회사별 If/else로 시스템을 설계한다면 인수 심사를 수행하는 소스는 SaaS형 어플리케이션을 사용하고자 하는 회사가 추가 될 때마다 수정되어야 하고 매번 배포를 해야 한다. 따라서 아래와 같은 방식으로 시스템을 설계하였다
•	인수 지침을 분석하여 회사별 공통으로 적용하는 인수 지침과 회사별로 특화되는 인수 지침을 구분하였다
•	구분된 지침 별로 회사별 구현 객체를 만들고 인수 심사 Check Operation을 만들었다
•	회사별로 Check 해야 하는 인수심사 객체를 회사별로 DB에 객체 정보를 관리한다
•	청약이 진행되어 인수 심사가 진행되면 회사별 인수 심사 객체의 목록을 DB에서 읽은 후 객체를 생성하여 인수 심사 결과를 저장할 수 있도록 한다
 

 
이 경우 신규 회사가 SaaS 어플리케이션을 구독하여 업무를 진행하게 될 경우 메인 로직인 인수 심사 요청의 모듈은 변경하지 않고 회사별로 변경되는 인수 심사 객체만 생성하여 배포하도록 설계하는 방식이다. 이러한 구조는 다른 회사에 영향없이 소스를 반영하고 수정할 수 있다는 장점이 있다. 그러나, 업무에 대한 가시성이 없으므로 유지보수가 어렵고, 이러한 규칙을 모를 경우 새롭게 로직을 풀어서 짜는 경우도 있다.
4.  서로 다른 화면 항목 설계
________________________________________
특히 화면의 경우에는 회사마다 관리하는 항목이 다를 수 밖에 없다. 이를 회사마다 화면을 신규로 개발할 것이 아니라, 각 회사별로 정의해야 하는 항목을 화면 별로 데이터 베이스로 관리하고 화면 Display 시 DB에서 화면 정보를 읽어 사용자에게 보여 줄 수 있는 방식으로 구성한다.
 
위의 그림은 간단하게 화면 항목을 관리하는 데이터 모델이다. 항목을 메타 형식으로 관리하는  항목메타정보를 관리하고, 관리된 항목을 화면의 변이 요소로 관리하거나, 테이블 컬럼의 변이 요소로 관리되는 매커니즘이다. 화면을 그릴 수 있는 정보를 <화면별항목> 테이블에 저장하여 화면을 그릴 때 마다 화면별항목을 읽어 화면을 display하는 방식이다. 물론 이 모델만으로 실제로 현장에서 적용될 수는 없다. 화면 그릴 때 속도와 방식에 대한 부분은 여러가지 형태로 적용될 수 있고, 사용자가 생각하기에 비효율적이라고 생각할 수도 있는 방식이다. 그럼에도 불구하고 이렇게까지 설계를 고민해야 하는 것은 여러 회사가 사용해야 할 SaaS형 어플리케이션이기 때문이다. 항목의 메타 정보와 화면별항목, 테이블 항목을 설정 정보로 입력만 하면 시스템이 돌아갈 수 있어야 하는 것이 SI 형 어플리케이션과 다른 점이기 때문이다.
5. 회사마다 다른 비즈니스 룰 처리
________________________________________
마지막으로 정의하고자 하는 것은 회사마다 다른 비즈니스 룰 처리 부분이다. 일반적으로 SI 형 프로젝트에서 결재 승인 라인을 정의할 경우 승인 라인을 정의하는 모듈을 만들고 그 모듈을 이용하여 승인 라인을 정의하도록 하였지만, 여러 회사의 결재 승인 라인은 같은 업무라고 해도 어느 경우에는 부서장이 될 수도 있고, 어느 경우에는 금액별 부서장, 담당 등으로 결재 라인이 변경 될 수도 있으며, 부서 유형에 따라 승인자가 달라지는 경우도 많이 있다. 이 모든 로직을 하나의 소스로 처리하려고 하면 회사별로 달라지는 업무 규칙, 즉 산술식, 처리조건 등의 변이를 데이터화하여 정보로 관리 하고 처리하도록 해야 한다. 간단하게 법인카드 한도 변경 가능 여부를 관리하는 프로그램을 구현하는 방식을 예를 들어 설명하고자 한다
[법인카드 한도 변경 룰]
회사 LG01 : 요건유형이 “B”이고, 한도금액이 2000보다  클 경우 가능
회사 LG02 : 직위는 팀장이어야 하고, 한도금액이 3000보다 클 경우 가능
이 룰을 비즈니스 룰에 대한 정보를 데이터로 관리한 뒤 저장된 룰 정보를 읽어 처리할 수 있도록 하는 방식으로 어플리케이션을 설계해야 한다
[법인카드 한도 변경 룰 데이터 입력 형태]
 
이 조건을 이용하여 설계했을 경우 SI 형 어플리케이션과 SaaS 형 어플리케이션의 차이를 Pseudo Code(의사코드) 형식으로 구현한 예이다
 
SI형 어플리케이션은 회사가 추가될 때마다 혹은 비즈니스 룰이 변경 될 때 마다 소스를 수정해야 하지만, SaaS 형 어플리케이션 형태의 경우 위에서 언급된 데이터 설정을 통해 바로 적용할 수 있도록 구현하는 것이다.
이 또한 룰 정보를 입력하는 설정 프로그램, 설정된 데이터를 읽어서 Return type마다 조합하여 Rule의 결과를 처리해야 하는 복잡한 공통 모듈, 비즈니스 룰을 이해할 수 없는 소스 코드, 설정 데이터가 잘못 입력될 경우 실행 로직이 바로 적용될 수 있는 위험성 등등 Pros&Cons가 많이 있다. 그럼에도 불구하고 앞서서 지속적으로 언급했던 변경용이성을 우선 순위로 하여 설계되어야 하기 때문에 SaaS형 어플리케이션으로 설계 및 구축되어야 하는 것이다.
6. 결론
________________________________________
이렇듯 SaaS 형 어플리케이션은 성능이나, 유지보수는 어렵지만 변경 용이성을 최대한 반영하여 설계를 해야 하며, 가장 중요한 것을 고객이 제시하는 요구 사항을 그대로 반영할 것이 아니라, 향후 요건 변경이 가능할 요소를 찾고 이 요소를 최대한 가변적으로 구성해야 하는 등 지금까지 우리가 했던 요구 사항을 잘 반영한 시스템이 아닌, 우리가 요구 사항을 잘 조정할 수 있는 시스템을 만들어야 한다.
현장에서는 “이렇게 고려해야 하는 것이 많은 방식으로 단납기와 작은 비용으로 만들 수 있나요?” 라는 현장의 목소리도 많지만, 향후 우리의 먹거리가 될 시스템이므로 좀 더 주인 의식을 반영하여 고민하고 또 고민하여 만들어야 할 것 같다.

